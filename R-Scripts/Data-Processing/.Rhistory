))
## Drop Series.Code column as can only have one timevar
melted.df <- melted.df[,colnames(melted.df) != "Series.Code"]
## Reshape into wide format
reshaped.df <- reshape(melted.df,
direction = "wide",
timevar = c("Series.Name"),
idvar = c("Country.Name","Country.Code","Year")
)
## Load plyr for mapvalues function
library(plyr)
## Update years using mapvalues
reshaped.df$Year <- mapvalues(as.character(reshaped.df$Year),
from = unique(as.character(reshaped.df$Year)),
to = substring(sapply(
strsplit(x = unique(as.character(reshaped.df$Year)), split = "[..]"),
"[[", 1),2)
)
## Replace .. representing missing values with NA
reshaped.df[reshaped.df == ".."] <- NA
reshaped.df
}
data.df <- worldbank_wide_to_long(file = "master_places_sheet.csv")
worldbank_wide_to_long <- function(file = NA){
if(is.na(file)){
stop('A file path must be provided to the named argument, file')
}
## Fill out empty rows that are at the bottom of the data file
imported.data <- read.csv(file,
fill = TRUE, na.strings = c("",".."))
## Check for expected column headings
missing.expected.cols <- setdiff(c("Country.Name","Country.Code","Series.Name"),
colnames(imported.data))
if(length(missing.expected.cols) >= 1){
stop(paste("The following column headings are expected but were not found: ",
print(missing.expected.cols, collapse = " ")))
}
## Identify the empty bottom rows by the Country.Code being obmitted
imported.data <- imported.data[!is.na(imported.data$Country.Code),]
## Load reshape2 for melt and reshape
library(reshape2)
## Melt year columns to one one column
melted.df <- suppressWarnings(melt(data = imported.data,
## Find columns that are dates
measure.vars = c(colnames(imported.data)[grepl("[..]YR",colnames(imported.data))]),
variable = "Year"
))
## Drop Series.Code column as can only have one timevar
melted.df <- melted.df[,colnames(melted.df) != "Series.Code"]
## Reshape into wide format
reshaped.df <- reshape(melted.df,
direction = "wide",
timevar = c("Series.Name"),
idvar = c("Country.Name","Country.Code","Year")
)
## Load plyr for mapvalues function
library(plyr)
## Update years using mapvalues
reshaped.df$Year <- mapvalues(as.character(reshaped.df$Year),
from = unique(as.character(reshaped.df$Year)),
to = substring(sapply(
strsplit(x = unique(as.character(reshaped.df$Year)), split = "[..]"),
"[[", 1),2)
)
## Replace .. representing missing values with NA
reshaped.df[reshaped.df == ".."] <- NA
reshaped.df
}
data.df <- worldbank_wide_to_long(file = "master_places_sheet.csv")
paste("Missing: oh", paste(foo, collapse = " "))
paste("Missing: oh this", paste(foo, collapse = " "))
paste("Missing: oh this", paste(foo, collapse = " "))
worldbank_wide_to_long <- function(file = NA){
if(is.na(file)){
stop('A file path must be provided to the named argument, file')
}
## Fill out empty rows that are at the bottom of the data file
imported.data <- read.csv(file,
fill = TRUE, na.strings = c("",".."))
## Check for expected column headings
missing.expected.cols <- setdiff(c("Country.Name","Country.Code","Series.Name"),
colnames(imported.data))
if(length(missing.expected.cols) >= 1){
stop(paste("The following column headings are expected but were not found: ",
print(missing.expected.cols, collapse = " "), sep = "fffuck"))
}
## Identify the empty bottom rows by the Country.Code being obmitted
imported.data <- imported.data[!is.na(imported.data$Country.Code),]
## Load reshape2 for melt and reshape
library(reshape2)
## Melt year columns to one one column
melted.df <- suppressWarnings(melt(data = imported.data,
## Find columns that are dates
measure.vars = c(colnames(imported.data)[grepl("[..]YR",colnames(imported.data))]),
variable = "Year"
))
## Drop Series.Code column as can only have one timevar
melted.df <- melted.df[,colnames(melted.df) != "Series.Code"]
## Reshape into wide format
reshaped.df <- reshape(melted.df,
direction = "wide",
timevar = c("Series.Name"),
idvar = c("Country.Name","Country.Code","Year")
)
## Load plyr for mapvalues function
library(plyr)
## Update years using mapvalues
reshaped.df$Year <- mapvalues(as.character(reshaped.df$Year),
from = unique(as.character(reshaped.df$Year)),
to = substring(sapply(
strsplit(x = unique(as.character(reshaped.df$Year)), split = "[..]"),
"[[", 1),2)
)
## Replace .. representing missing values with NA
reshaped.df[reshaped.df == ".."] <- NA
reshaped.df
}
data.df <- worldbank_wide_to_long(file = "master_places_sheet.csv")
worldbank_wide_to_long <- function(file = NA){
if(is.na(file)){
stop('A file path must be provided to the named argument, file')
}
## Fill out empty rows that are at the bottom of the data file
imported.data <- read.csv(file,
fill = TRUE, na.strings = c("",".."))
## Check for expected column headings
missing.expected.cols <- setdiff(c("Country.Name","Country.Code","Series.Name"),
colnames(imported.data))
if(length(missing.expected.cols) >= 1){
stop(c("The following column headings are expected but were not found: ",
print(missing.expected.cols, collapse = " ")))
}
## Identify the empty bottom rows by the Country.Code being obmitted
imported.data <- imported.data[!is.na(imported.data$Country.Code),]
## Load reshape2 for melt and reshape
library(reshape2)
## Melt year columns to one one column
melted.df <- suppressWarnings(melt(data = imported.data,
## Find columns that are dates
measure.vars = c(colnames(imported.data)[grepl("[..]YR",colnames(imported.data))]),
variable = "Year"
))
## Drop Series.Code column as can only have one timevar
melted.df <- melted.df[,colnames(melted.df) != "Series.Code"]
## Reshape into wide format
reshaped.df <- reshape(melted.df,
direction = "wide",
timevar = c("Series.Name"),
idvar = c("Country.Name","Country.Code","Year")
)
## Load plyr for mapvalues function
library(plyr)
## Update years using mapvalues
reshaped.df$Year <- mapvalues(as.character(reshaped.df$Year),
from = unique(as.character(reshaped.df$Year)),
to = substring(sapply(
strsplit(x = unique(as.character(reshaped.df$Year)), split = "[..]"),
"[[", 1),2)
)
## Replace .. representing missing values with NA
reshaped.df[reshaped.df == ".."] <- NA
reshaped.df
}
data.df <- worldbank_wide_to_long(file = "master_places_sheet.csv")
worldbank_wide_to_long <- function(file = NA){
if(is.na(file)){
stop('A file path must be provided to the named argument, file')
}
## Fill out empty rows that are at the bottom of the data file
imported.data <- read.csv(file,
fill = TRUE, na.strings = c("",".."))
## Check for expected column headings
missing.expected.cols <- setdiff(c("Country.Name","Country.Code","Series.Name"),
colnames(imported.data))
if(length(missing.expected.cols) >= 1){
stop(c("The following column headings are expected but were not found: ",
print(missing.expected.cols, sep = ", ")))
}
## Identify the empty bottom rows by the Country.Code being obmitted
imported.data <- imported.data[!is.na(imported.data$Country.Code),]
## Load reshape2 for melt and reshape
library(reshape2)
## Melt year columns to one one column
melted.df <- suppressWarnings(melt(data = imported.data,
## Find columns that are dates
measure.vars = c(colnames(imported.data)[grepl("[..]YR",colnames(imported.data))]),
variable = "Year"
))
## Drop Series.Code column as can only have one timevar
melted.df <- melted.df[,colnames(melted.df) != "Series.Code"]
## Reshape into wide format
reshaped.df <- reshape(melted.df,
direction = "wide",
timevar = c("Series.Name"),
idvar = c("Country.Name","Country.Code","Year")
)
## Load plyr for mapvalues function
library(plyr)
## Update years using mapvalues
reshaped.df$Year <- mapvalues(as.character(reshaped.df$Year),
from = unique(as.character(reshaped.df$Year)),
to = substring(sapply(
strsplit(x = unique(as.character(reshaped.df$Year)), split = "[..]"),
"[[", 1),2)
)
## Replace .. representing missing values with NA
reshaped.df[reshaped.df == ".."] <- NA
reshaped.df
}
data.df <- worldbank_wide_to_long(file = "master_places_sheet.csv")
worldbank_wide_to_long <- function(file = NA){
if(is.na(file)){
stop('A file path must be provided to the named argument, file')
}
## Fill out empty rows that are at the bottom of the data file
imported.data <- read.csv(file,
fill = TRUE, na.strings = c("",".."))
## Check for expected column headings
missing.expected.cols <- setdiff(c("Country.Name","Country.Code","Series.Name"),
colnames(imported.data))
if(length(missing.expected.cols) >= 1){
stop(c("The following column headings are expected but were not found: ",
print(missing.expected.cols, collapse = ", ")))
}
## Identify the empty bottom rows by the Country.Code being obmitted
imported.data <- imported.data[!is.na(imported.data$Country.Code),]
## Load reshape2 for melt and reshape
library(reshape2)
## Melt year columns to one one column
melted.df <- suppressWarnings(melt(data = imported.data,
## Find columns that are dates
measure.vars = c(colnames(imported.data)[grepl("[..]YR",colnames(imported.data))]),
variable = "Year"
))
## Drop Series.Code column as can only have one timevar
melted.df <- melted.df[,colnames(melted.df) != "Series.Code"]
## Reshape into wide format
reshaped.df <- reshape(melted.df,
direction = "wide",
timevar = c("Series.Name"),
idvar = c("Country.Name","Country.Code","Year")
)
## Load plyr for mapvalues function
library(plyr)
## Update years using mapvalues
reshaped.df$Year <- mapvalues(as.character(reshaped.df$Year),
from = unique(as.character(reshaped.df$Year)),
to = substring(sapply(
strsplit(x = unique(as.character(reshaped.df$Year)), split = "[..]"),
"[[", 1),2)
)
## Replace .. representing missing values with NA
reshaped.df[reshaped.df == ".."] <- NA
reshaped.df
}
data.df <- worldbank_wide_to_long(file = "master_places_sheet.csv")
worldbank_wide_to_long <- function(file = NA){
if(is.na(file)){
stop('A file path must be provided to the named argument, file')
}
## Fill out empty rows that are at the bottom of the data file
imported.data <- read.csv(file,
fill = TRUE, na.strings = c("",".."))
## Check for expected column headings
missing.expected.cols <- setdiff(c("Country.Name","Country.Code","Series.Name"),
colnames(imported.data))
if(length(missing.expected.cols) >= 1){
stop(c("The following column headings are expected but were not found: ",
print(missing.expected.cols)))
}
## Identify the empty bottom rows by the Country.Code being obmitted
imported.data <- imported.data[!is.na(imported.data$Country.Code),]
## Load reshape2 for melt and reshape
library(reshape2)
## Melt year columns to one one column
melted.df <- suppressWarnings(melt(data = imported.data,
## Find columns that are dates
measure.vars = c(colnames(imported.data)[grepl("[..]YR",colnames(imported.data))]),
variable = "Year"
))
## Drop Series.Code column as can only have one timevar
melted.df <- melted.df[,colnames(melted.df) != "Series.Code"]
## Reshape into wide format
reshaped.df <- reshape(melted.df,
direction = "wide",
timevar = c("Series.Name"),
idvar = c("Country.Name","Country.Code","Year")
)
## Load plyr for mapvalues function
library(plyr)
## Update years using mapvalues
reshaped.df$Year <- mapvalues(as.character(reshaped.df$Year),
from = unique(as.character(reshaped.df$Year)),
to = substring(sapply(
strsplit(x = unique(as.character(reshaped.df$Year)), split = "[..]"),
"[[", 1),2)
)
## Replace .. representing missing values with NA
reshaped.df[reshaped.df == ".."] <- NA
reshaped.df
}
data.df <- worldbank_wide_to_long(file = "master_places_sheet.csv")
paste(foo, collapse = " ")
paste(foo, collapse = ", ")
worldbank_wide_to_long <- function(file = NA){
if(is.na(file)){
stop('A file path must be provided to the named argument, file')
}
## Fill out empty rows that are at the bottom of the data file
imported.data <- read.csv(file,
fill = TRUE, na.strings = c("",".."))
## Check for expected column headings
missing.expected.cols <- setdiff(c("Country.Name","Country.Code","Series.Name"),
colnames(imported.data))
if(length(missing.expected.cols) >= 1){
missing.expected.cols <- paste(missing.expected.cols, collapse = ", ")
stop(c("The following column headings are expected but were not found: ",
missing.expected.cols))
}
## Identify the empty bottom rows by the Country.Code being obmitted
imported.data <- imported.data[!is.na(imported.data$Country.Code),]
## Load reshape2 for melt and reshape
library(reshape2)
## Melt year columns to one one column
melted.df <- suppressWarnings(melt(data = imported.data,
## Find columns that are dates
measure.vars = c(colnames(imported.data)[grepl("[..]YR",colnames(imported.data))]),
variable = "Year"
))
## Drop Series.Code column as can only have one timevar
melted.df <- melted.df[,colnames(melted.df) != "Series.Code"]
## Reshape into wide format
reshaped.df <- reshape(melted.df,
direction = "wide",
timevar = c("Series.Name"),
idvar = c("Country.Name","Country.Code","Year")
)
## Load plyr for mapvalues function
library(plyr)
## Update years using mapvalues
reshaped.df$Year <- mapvalues(as.character(reshaped.df$Year),
from = unique(as.character(reshaped.df$Year)),
to = substring(sapply(
strsplit(x = unique(as.character(reshaped.df$Year)), split = "[..]"),
"[[", 1),2)
)
## Replace .. representing missing values with NA
reshaped.df[reshaped.df == ".."] <- NA
reshaped.df
}
data.df <- worldbank_wide_to_long(file = "master_places_sheet.csv")
### =======================================================================
### ==== Processing Files from http://databank.worldbank.org/ ============
### This code file will import an exported dataset from the worldbank,
### Convert the file to long format and drop unnecessary information
worldbank_wide_to_long <- function(file = NA){
if(is.na(file)){
stop('A file path must be provided to the named argument, file')
}
## Fill out empty rows that are at the bottom of the data file
imported.data <- read.csv(file,
fill = TRUE, na.strings = c("",".."))
## Check for expected column headings
missing.expected.cols <- setdiff(c("Country.Name","Country.Code","Series.Name"),
colnames(imported.data))
if(length(missing.expected.cols) >= 1){
missing.expected.cols <- paste(missing.expected.cols, collapse = ", ")
stop(c("The following column headings were expected but were not found: ",
missing.expected.cols))
}
## Identify the empty bottom rows by the Country.Code being obmitted
imported.data <- imported.data[!is.na(imported.data$Country.Code),]
## Load reshape2 for melt and reshape
library(reshape2)
## Melt year columns to one one column
melted.df <- suppressWarnings(melt(data = imported.data,
## Find columns that are dates
measure.vars = c(colnames(imported.data)[grepl("[..]YR",colnames(imported.data))]),
variable = "Year"
))
## Drop Series.Code column as can only have one timevar
melted.df <- melted.df[,colnames(melted.df) != "Series.Code"]
## Reshape into wide format
reshaped.df <- reshape(melted.df,
direction = "wide",
timevar = c("Series.Name"),
idvar = c("Country.Name","Country.Code","Year")
)
## Load plyr for mapvalues function
library(plyr)
## Update years using mapvalues
reshaped.df$Year <- mapvalues(as.character(reshaped.df$Year),
from = unique(as.character(reshaped.df$Year)),
to = substring(sapply(
strsplit(x = unique(as.character(reshaped.df$Year)), split = "[..]"),
"[[", 1),2)
)
## Replace .. representing missing values with NA
reshaped.df[reshaped.df == ".."] <- NA
reshaped.df
}
data.df <- worldbank_wide_to_long(file = "master_places_sheet.csv")
data.df
data.df <- worldbank_wide_to_long(file = "master_places_sheet.csv")
data.df <- worldbank_wide_to_long(file = "Data_Extract_From_World_Development_Indicators_Data.csv")
data.df
install.packages('WDI')
dat = WDI(indicator=c('NY.GDP.PCAP.KD',"BN.CAB.XOKA.GD.ZS"), country=c('MX','CA','US'), start=1960, end=2012)
library(WDI)
dat <- WDI(indicator=c('NY.GDP.PCAP.KD',"BN.CAB.XOKA.GD.ZS"), country=c('MX','CA','US'), start=1960, end=2012)
str(dat)
worldbank_wide_to_long <- function(file = NA){
if(file.exists(file)){
stop('A file path must be provided to the named argument, file')
}
## Fill out empty rows that are at the bottom of the data file
imported.data <- read.csv(file,
fill = TRUE, na.strings = c("",".."))
## Check for expected column headings
missing.expected.cols <- setdiff(c("Country.Name","Country.Code","Series.Name"),
colnames(imported.data))
## If missing columns are found then stop and return an error
if(length(missing.expected.cols) >= 1){
missing.expected.cols <- paste(missing.expected.cols, collapse = ", ")
stop(c("The following column headings were expected but were not found: ",
missing.expected.cols))
}
## Identify the empty bottom rows by the Country.Code being obmitted
imported.data <- imported.data[!is.na(imported.data$Country.Code),]
## Load reshape2 for melt and reshape
library(reshape2)
## Melt year columns to one one column
melted.df <- suppressWarnings(melt(data = imported.data,
## Find columns that are dates
measure.vars = c(colnames(imported.data)[grepl("[..]YR",colnames(imported.data))]),
variable = "Year"
))
## Drop Series.Code column as can only have one timevar
melted.df <- melted.df[,colnames(melted.df) != "Series.Code"]
## Reshape into wide format
reshaped.df <- reshape(melted.df,
direction = "wide",
timevar = c("Series.Name"),
idvar = c("Country.Name","Country.Code","Year")
)
## Load plyr for mapvalues function
library(plyr)
## Update years using mapvalues
reshaped.df$Year <- mapvalues(as.character(reshaped.df$Year),
from = unique(as.character(reshaped.df$Year)),
to = substring(sapply(
strsplit(x = unique(as.character(reshaped.df$Year)), split = "[..]"),
"[[", 1),2)
)
## Replace .. representing missing values with NA
reshaped.df[reshaped.df == ".."] <- NA
reshaped.df
}
data.df <- worldbank_wide_to_long(file = "Data_Extract_From_World_Development_Indicators_Data.csv")
read.csv(""Data_Extract_From_World_Development_Indicators_Data.csv"")
read.csv("Data_Extract_From_World_Development_Indicators_Data.csv")
file.exists("Data_Extract_From_World_Development_Indicators_Data.csv")
worldbank_wide_to_long <- function(file = NA){
if(!file.exists(file)){
stop('A file path must be provided to the named argument, file')
}
## Fill out empty rows that are at the bottom of the data file
imported.data <- read.csv(file,
fill = TRUE, na.strings = c("",".."))
## Check for expected column headings
missing.expected.cols <- setdiff(c("Country.Name","Country.Code","Series.Name"),
colnames(imported.data))
## If missing columns are found then stop and return an error
if(length(missing.expected.cols) >= 1){
missing.expected.cols <- paste(missing.expected.cols, collapse = ", ")
stop(c("The following column headings were expected but were not found: ",
missing.expected.cols))
}
## Identify the empty bottom rows by the Country.Code being obmitted
imported.data <- imported.data[!is.na(imported.data$Country.Code),]
## Load reshape2 for melt and reshape
library(reshape2)
## Melt year columns to one one column
melted.df <- suppressWarnings(melt(data = imported.data,
## Find columns that are dates
measure.vars = c(colnames(imported.data)[grepl("[..]YR",colnames(imported.data))]),
variable = "Year"
))
## Drop Series.Code column as can only have one timevar
melted.df <- melted.df[,colnames(melted.df) != "Series.Code"]
## Reshape into wide format
reshaped.df <- reshape(melted.df,
direction = "wide",
timevar = c("Series.Name"),
idvar = c("Country.Name","Country.Code","Year")
)
## Load plyr for mapvalues function
library(plyr)
## Update years using mapvalues
reshaped.df$Year <- mapvalues(as.character(reshaped.df$Year),
from = unique(as.character(reshaped.df$Year)),
to = substring(sapply(
strsplit(x = unique(as.character(reshaped.df$Year)), split = "[..]"),
"[[", 1),2)
)
## Replace .. representing missing values with NA
reshaped.df[reshaped.df == ".."] <- NA
reshaped.df
}
data.df <- worldbank_wide_to_long(file = "Data_Extract_From_World_Development_Indicators_Data.csv")
data.df
data.df <- worldbank_wide_to_long(file = "fuck")
